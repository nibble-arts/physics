//var gl;
var stage;

var Physics = {
	damping: 5,
	gravity: { x: 0, y: 0 },
};


//================================================================
// create stage with objects
function load() {

	stage = new Kinetic.Stage({
		container: "table",
		width: 1000,
		height: 800,
		stroke: "black",
		strokeWidth: 1,
	});

	var layer = new Kinetic.Layer();


// create objects
	var greenbox = new Kinetic.Rect({
		name: "green",
		x: 200,
		y: 50,
		width: 100,
		height: 50,
		offsetX: 50,
		offsetY: 25,
		fill: "green",
		stroke: "black",
		strikeWidth: 4,
//		shadowColor: "black",
//		shadowBlur: 10,
//		shadowOffset: { x:4,y:4 },
//		shadowOpacity: 0.5,
		draggable: true,
    dragBoundFunc: function(pos) {
			getDrag(this);
			setRotation(this);
			getCollision(this);

    	return {
    		x: pos.x,
    		y: pos.y,
    	}
    }
	});
	layer.add(greenbox);

	var redbox = new Kinetic.Rect({
		name: "red",
		x: 400,
		y: 150,
		width: 100,
		height: 100,
		offsetX: 50,
		offsetY: 50,
		fill: "red",
		stroke: "black",
		strikeWidth: 4,
//		shadowColor: "black",
//		shadowBlur: 10,
//		shadowOffset: { x:4,y:4 },
//		shadowOpacity: 0.5,
		draggable: true,
    dragBoundFunc: function(pos) {
			getDrag(this);
			setRotation(this);
			getCollision(this);

    	return {
    		x: pos.x,
    		y: pos.y,
    	}
    }
	});
	layer.add(redbox);

	var bluebox = new Kinetic.Rect({
		name: "blue",
		x: 400,
		y: 300,
		width: 100,
		height: 50,
		offsetX: 50,
		offsetY: 25,
		fill: "blue",
		stroke: "black",
		strikeWidth: 4,
//		shadowColor: "black",
//		shadowBlur: 10,
//		shadowOffset: { x:4,y:4 },
//		shadowOpacity: 0.5,
		draggable: true,
    dragBoundFunc: function(pos) {
			getDrag(this);
			setRotation(this);
			getCollision(this);

    	return {
    		x: pos.x,
    		y: pos.y
    	}
    }
	});
	layer.add(bluebox);


// add layer to stage
	stage.add(layer);


// set drag events
	greenbox.on("dragend", function () {
		if (this.speed > 1) {
			animate(this);
		}
	});

	bluebox.on("dragend", function () {
		if (this.speed > 1) {
			animate(this);
		}
	});

	redbox.on("dragend", function () {
		if (this.speed > 1) {
			animate(this);
		}
	});


// set click events
	greenbox.on("click", function () {
		this.moveToTop();
		layer.draw();
	});

	bluebox.on("click", function () {
		this.moveToTop();
		layer.draw();
	});

	redbox.on("click", function () {
		this.moveToTop();
		layer.draw();
	});
}


//================================================================
// get excenricy of object
function getDrag(node) {
	var oldMouse = {};

	var mouse = stage.getPointerPosition();
	var pos = node.getAbsolutePosition();

	(stage.oldMouse) ? oldMouse = stage.oldMouse:oldMouse=mouse;
	stage.oldMouse = mouse;

	node.px = mouse.x;
	node.py = mouse.y;
	
	node.vx = mouse.x - oldMouse.x;
	node.vy = mouse.y - oldMouse.y;
	node.speed = Math.abs(Math.sqrt(node.vx*node.vx + node.vy*node.vy));

	node.dx = mouse.x - pos.x;
	node.dy = mouse.y - pos.y;
	node.radius = Math.sqrt(node.dx*node.dx + node.dy*node.dy);
}


//================================================================
// dragoff inertia animation
function animate (node) {
	var layer = node.getLayer();
	
	var damping = Physics.damping;

	var dampX = Math.abs(node.vx/100 * damping);
	var dampY = Math.abs(node.vy/100 * damping);

	var anim = new Kinetic.Animation(function(frame) {
		node.x(node.getPosition().x+node.vx);
		node.y(node.getPosition().y+node.vy);

// canvas collision
		if (node.getPosition().x > stage.getWidth()) node.vx = -node.vx;
		if (node.getPosition().x < stage.getPosition().x) node.vx = -node.vx;
		if (node.getPosition().y > stage.getHeight()) node.vy = -node.vy;
		if (node.getPosition().y < stage.getPosition().y) node.vy = -node.vy;

// damping
		if (Math.round(node.vx))
			(node.vx > 0) ? node.vx -= dampX:node.vx += dampX;
		else node.vx = 0;

		if (Math.round(node.vy))
			(node.vy > 0) ? node.vy -= dampY:node.vy +=dampY;
		else node.vy = 0;
		
		node.speed = Math.abs(Math.sqrt(node.vx*node.vx + node.vy*node.vy));

		if (!Math.round(node.speed)) anim.stop()

//				if (frame.time > 10000) anim.stop();
  }, layer);

	anim.start();
}


//================================================================
// rotation
function setRotation (node) {
	var v = new Vector(node.vx,-node.vy);
	var d = new Vector(node.dx,-node.dy);

	if(v.abs()) {
		var angle = Math.acos(Math.abs(Vector.product(v,d)) / (v.abs() * d.abs()));
		var ex = Vector.ex(v,d);
	
		if (ex.z)
			node.setRotation(node.getRotation() + angle * ex.z / Math.abs(ex.z));
	}
}


//================================================================
// get collisions
function getCollision (node) {
	var objects = stage.find("Rect");

	objects.each(function (shape) {
		if (node.getName() != shape.getName()) {
			var dist = getDistance(node,shape);

//		getIntersections(node,shape);

			if (dist.abs() < 100) {
//console.log(dist.unify().scale(node.speed).y);
				shape.vx = dist.unify().scale(node.speed).x;
				shape.vy = dist.unify().scale(node.speed).y;

				animate(shape);
			}
		}
/*		if (doObjectsCollide(node,shape) && node.getName() != shape.getName()) {
			var dist = getDistance(node,shape);

			shape.vx = dist.unify().scale(node.speed).x;
			shape.vy = dist.unify().scale(node.speed).y;

			animate(shape);

			$("#x").html("object: "+shape.getName());
			$("#y").html("dist: "+node.speed);
		}
		else {
//			$("#x").html("");
//			$("#y").html("");
		}*/
	});
}


//================================================================
// intersect rectangles
function getIntersections (node,shape) {
	if (node.getName() != shape.getName()) {
		var nodeLines = getlines(node);
		var shapeLines = getlines(shape);

	// intersect lines of node with shape
		$.each(nodeLines, function (i,nl) {
			$.each(shapeLines, function (j,sl) {
				Line.intersect(nl,sl);
			});
		});
	}
}


//================================================================
// get array of lines from rectangle
function getlines (node) {
	var x = node.getX();
	var y = node.getY();

	var width = node.getWidth();
	var height = node.getHeight();
	var angle = node.getRotation();
	var offset = node.getOffset();

	var p1 = new Vector(-offset.x,-offset.y);
	var p2 = new Vector(-offset.x+width,-offset.y);
	var p3 = new Vector(-offset.x+width,-offset.y+height);
	var p4 = new Vector(-offset.x,-offset.y+height);

	var v1 = p1.rotate(angle).translate(x,y);
	var v2 = p2.rotate(angle).translate(x,y);
	var v3 = p3.rotate(angle).translate(x,y);
	var v4 = p4.rotate(angle).translate(x,y);

	var lines = new Array;
	lines.push(new Line(v1,v2));
	lines.push(new Line(v2,v3));
	lines.push(new Line(v3,v4));
	lines.push(new Line(v4,v1));

	return lines;
}


//================================================================
// check for collision
function doObjectsCollide(a, b) { // a and b are your objects
	return !(
		((a.getY() - a.getOffsetY() + a.getHeight()) < (b.getY() - b.getOffsetY())) ||
		((a.getY() - a.getOffsetY()) > (b.y - b.getOffsetY() + b.getHeight())) ||
		((a.getX() - a.getOffsetX() + a.getWidth()) < (b.getX() - b.getOffsetX())) ||
		((a.getX() - a.getOffsetX()) > (b.getX() - b.getOffsetX() + b.getWidth()))
	);
}


//================================================================
// check for collision of rotated rectangles
function isCollision(a,b) {

	var x10 = a.getX();
	var y10 = a.getY();
	var height1 = a.getHeight() / 2;
	var width1 = a.getWidth() / 2;

	var x20 = b.getX();
	var y20 = b.getY();
	var height2 = b.getHeight() / 2;
	var width2 = b.getWidth() / 2;

	var radrot1 = a.getRotation();
	var radrot2 = b.getRotation();
	
	var radius1 = Math.sqrt( height1*height1 + width1*width1 );
	var radius2 = Math.sqrt( height2*height2 + width2*width2 );
     
	var angle1 = Math.asin( height1 / radius1 );
	var angle2 = Math.asin( height2 / radius2 );
     
	var x1 = new Array;
	var y1 = new Array;
	var x2 = new Array;
	var y2 = new Array;
     
	x1[1] = x10 + radius1 * Math.cos(radrot1 - angle1);
	y1[1] = y10 + radius1 * Math.sin(radrot1 - angle1);

	x1[2] = x10 + radius1 * Math.cos(radrot1 + angle1);
	y1[2] = y10 + radius1 * Math.sin(radrot1 + angle1);
	
	x1[3] = x10 + radius1 * Math.cos(radrot1 + Math.pi - angle1);
	y1[3] = y10 + radius1 * Math.sin(radrot1 + Math.pi - angle1);
	
	x1[4] = x10 + radius1 * Math.cos(radrot1 + Math.pi + angle1);
	y1[4] = y10 + radius1 * Math.sin(radrot1 + Math.pi + angle1);
     
	x2[1] = x20 + radius2 * Math.cos(radrot2 - angle2);
	y2[1] = y20 + radius2 * Math.sin(radrot2 - angle2);
	
	x2[2] = x20 + radius2 * Math.cos(radrot2 + angle2);
	y2[2] = y20 + radius2 * Math.sin(radrot2 + angle2);
	
	x2[3] = x20 + radius2 * Math.cos(radrot2 + Math.pi - angle2);
	y2[3] = y20 + radius2 * Math.sin(radrot2 + Math.pi - angle2);
	
	x2[4] = x20 + radius2 * Math.cos(radrot2 + Math.pi + angle2);
	y2[4] = y20 + radius2 * Math.sin(radrot2 + Math.pi + angle2);
     
	var axisx = {};
	var axisy = {};
     
	axisx[1] = x1[1] - x1[2];
	axisy[1] = y1[1] - y1[2];
	
	axisx[2] = x1[3] - x1[2];
	axisy[2] = y1[3] - y1[2];
	
	axisx[3] = x2[1] - x2[2];
	axisy[3] = y2[1] - y2[2];
	axisx[4] = x2[3] - x2[2];
	axisy[4] = y2[3] - y2[2];
     
	for (var k = 1;k < 4;k++) {
    var proj = x1[1] * axisx[k] + y1[1] * axisy[k];
     
		var minProj1 = proj;
		var maxProj1 = proj;
     
		for (var i = 2;i < 4;i++) {
	    proj = x1[i] * axisx[k] + y1[i] * axisy[k];
     
		  if (proj < minProj1)
			  minProj1 = proj;
		  else {
		  	if (proj > maxProj1)
		  		maxProj1 = proj;
			}
		}
     
    proj = x2[1] * axisx[k] + y2[1] * axisy[k];
     
    var minProj2 = proj;
    var maxProj2 = proj;
     
    for (var j = 2;j < 4;j++) {
	    proj = x2[j] * axisx[k] + y2[j] * axisy[k];
     
		  if (proj < minProj2)
			  minProj2 = proj;
		  else {
		  	if (proj > maxProj2)
		  		maxProj2 = proj;
		  }
		}
		     
		if (maxProj2 < minProj1 || maxProj1 < minProj2)
			return false;
	}
	return true;
}


//================================================================
// get distance of object centers
function getDistance (a,b) {
	return new Vector(b.getX()-a.getX(),b.getY()-a.getY());
}


//================================================================
//================================================================
// vector arithmetics
function Vector (x,y,z) {
	this.x = x;
	this.y = y;
	(z) ? this.z = z:this.z = 0;
}

// return vector as string
Vector.prototype.toString = function () {
	return ("("+this.x+","+this.y+","+this.z+")");
}

// return length of vector
Vector.prototype.abs = function () {
	return (Math.sqrt(Math.pow(this.x,2) + Math.pow(this.y,2) +Math.pow(this.z,2)));
}

// multiply vector
Vector.prototype.scale = function (s) {
	return new Vector (this.x*s,this.y*s,this.z*s);
}

// normate vector
Vector.prototype.unify = function () {
	return (this.scale(1/this.abs()));
}

// rotate vector
Vector.prototype.rotate = function (angle) {
	angle = angle / 180 * Math.PI;
	
	var x = (this.x * Math.cos(angle)) - (this.y * Math.sin(angle));
	var y = (this.x * Math.sin(angle)) + (this.y * Math.cos(angle));

	return new Vector(x,y);
}

// translate vector
Vector.prototype.translate = function (x,y,z) {
	if (!z) z = 0;
	return new Vector(this.x+x,this.y+y,this.z+z);
}

// return scalar procuct of vectors
Vector.product = function (v1,v2) {
	return (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);
}

// return ex-product of vectors
Vector.ex = function (v1,v2) {
	var x = (v1.y * v2.z) - (v1.z * v2.y);
	var y = (v1.x * v2.z) - (v1.z * v2.x);
	var z = (v1.x * v2.y) - (v1.y * v2.x);

	return new Vector(x,y,z);
}



//================================================================
//================================================================
// line arithmetics
function Line (v1,v2) {
	this.v1 = v1;
	this.v2 = v2;
}

// get intersection point for two lines
Line.intersect = function (l1,l2) {
	var a1 = l1.v1;
	var a2 = l1.v2;
	var b1 = l2.v1;
	var b2 = l2.v2;

	var ua;
	var ub;

	var nom = ((b2.y-b1.y)*(a2.x-a1.x))-((b2.x-b1.x)*(a2.y-a1.y));
	if (nom) {

		ua = ((b2.x-b1.x)*(a1.y-b1.y))-((b2.y-b1.y)*(a1.x-b1.x)) / nom;
		ub = ((a2.x-a1.x)*(a1.y-b1.y))-((a2.y-a1.y)*(a1.x-b1.x)) / nom;

console.log(ua+" "+ub);

		if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)
			return new Vector(ua,ub);
		else return false;
	}
	else return false;
}

